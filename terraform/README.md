# Terraform Infrastructure

This directory contains Terraform modules and environment configurations for provisioning Kubernetes resources through the Imperm middleware.

## Directory Structure

```
terraform/
├── modules/           # Reusable Terraform modules
│   └── k8s-namespace/ # Module for creating K8s namespaces with optional resources
│       ├── main.tf        # Main resource definitions
│       ├── variables.tf   # Input variables
│       ├── outputs.tf     # Output values
│       └── README.md      # Module documentation
│
└── environments/      # Environment-specific configurations
    └── <env-name>/    # Auto-generated by middleware
        ├── main.tf        # Generated configuration using modules
        └── .terraform/    # Terraform state and plugins
```

## Modules

### k8s-namespace

A reusable module for creating Kubernetes namespaces with optional starter resources.

**Features:**
- Creates a labeled Kubernetes namespace
- Optional nginx deployment with resource limits
- Optional ClusterIP service
- Input validation for namespace names

**Usage:**
```hcl
module "environment" {
  source = "./modules/k8s-namespace"

  namespace_name = "my-environment"
  with_options   = true  # Creates sample deployment and service
}
```

See [modules/k8s-namespace/README.md](modules/k8s-namespace/README.md) for full documentation.

## How Environments are Created

When you create an environment through the Imperm API:

1. **Directory Creation**: A new directory is created in `environments/<env-name>/`
2. **Configuration Generation**: The middleware generates a `main.tf` that:
   - Configures the Kubernetes provider with your kubeconfig
   - Uses the `k8s-namespace` module
   - Defines outputs for namespace info
3. **Terraform Init**: Runs `terraform init` to download providers and modules
4. **Terraform Apply**: Runs `terraform apply -auto-approve` to create resources

## Environment Lifecycle

### Create Environment
```bash
# Via API
curl -X POST http://localhost:8080/api/environments/create \
  -H "Content-Type: application/json" \
  -d '{"name": "dev-env-1", "with_options": true}'
```

This creates:
- `terraform/environments/dev-env-1/main.tf`
- `terraform/environments/dev-env-1/.terraform/` (state)
- Kubernetes namespace `dev-env-1`
- Optional: nginx deployment and service

### List Environments
```bash
curl http://localhost:8080/api/environments
```

The middleware scans the `environments/` directory and parses Terraform state.

### Destroy Environment
```bash
curl -X POST http://localhost:8080/api/environments/destroy \
  -H "Content-Type: application/json" \
  -d '{"name": "dev-env-1"}'
```

This runs:
- `terraform destroy -auto-approve`
- Removes the `terraform/environments/dev-env-1/` directory

## Configuration

### Environment Variables

- `IMPERM_PROJECT_ROOT`: Project root directory (auto-detected if not set)
- `KUBECONFIG`: Path to kubeconfig file (defaults to `~/.kube/config`)

### Provider Configuration

The generated Terraform configurations use the Kubernetes provider:

```hcl
provider "kubernetes" {
  config_path = "~/.kube/config"  # From KUBECONFIG env var
}
```

Ensure your kubeconfig is valid and points to the correct cluster.

## Adding Custom Modules

To add new Terraform modules:

1. Create a new directory in `modules/`:
```bash
mkdir -p modules/my-custom-module
```

2. Add Terraform files:
```
modules/my-custom-module/
├── main.tf
├── variables.tf
├── outputs.tf
└── README.md
```

3. Update the middleware's Terraform client to use your module
4. Regenerate configurations or create new environment types

## State Management

Terraform state is stored locally in each environment directory:
```
environments/<env-name>/.terraform/
environments/<env-name>/terraform.tfstate
```

**Important Notes:**
- State files contain sensitive data - do not commit to version control
- For production, consider using remote state (S3, Terraform Cloud, etc.)
- Deleting state files will cause Terraform to lose track of resources

## Troubleshooting

### Terraform not found
```bash
brew install terraform
terraform version
```

### Provider authentication errors
Ensure your kubeconfig is valid:
```bash
kubectl config current-context
kubectl get nodes
```

### State locked
If Terraform complains about state locking:
```bash
cd terraform/environments/<env-name>
terraform force-unlock <lock-id>
```

### Environment already exists in K8s
If resources exist but Terraform doesn't know about them, you may need to import:
```bash
cd terraform/environments/<env-name>
terraform import kubernetes_namespace.environment <namespace-name>
```

## Best Practices

1. **Version Control**: Commit modules but not generated environments
2. **State Backends**: Use remote state for production
3. **Module Versioning**: Tag module versions for stability
4. **Testing**: Test module changes before deploying
5. **Documentation**: Keep module READMEs up to date
